@abc123456  6100311085@Bgn    jupyter lab --dev-mode
@Lm546486

git:账号：limiao 密码：tFKofxwiZMVcesVj

boolean love = you.love_me ? true : false;
“手怎么了？”
“啊，没事，内存边界溢出了。”



mvn install:install-file -Dfile=C:\Users\Administrator\Desktop\SpecialTestWeb\special4java\lib\JythonHelper.jar -DgroupId=com.oppo.specialtest -DartifactId=JythonHelper -Dversion=1.0 -Dpackaging=jar
 

zt#19880620


47.97.208.81(公)

172.16.218.231(私有)  5672/5672 15672/15672



1.JDK和JRE的区别
    JRE是JAVA的最核心的部分,可以认为是JAVA的基础环境,包括虚拟机和java.exe(运行命令)
    JDK是由程序员开发的JAVA核心的组件,包括基础jar包/源码以及javac.exe(编译命令)

为什么会有线程安全性问题？
	当多个线程同时共享同一个全局变量或静态变量，做写的操作时，可能会发生数据冲突问题
		也就是线程安全问题，但是在做读写操作时不会发生数据冲突问题

解决办法：synchronized -- 自动锁
	  lock -- jdk1.5并发包 -- 手动锁

线程之间如何同步？
	同步是保证数据原子性，原子性就是数据不能受到其他线程干扰

什么是同步代码块？
	就是将可能会发生线程安全问题的代码给包裹起来

synchronized原理：
1.首先有一个线程已经拿到了锁，其他线程已经有cup执行权，一直排队，等待释放锁。
2.锁是在什么时候释放？代码执行完毕或者程序抛出异常都会被释放掉。
3.锁已经被释放掉的话，其他线程开始进行抢锁（资源竞争），谁抢到谁进入同步中去，其他线程继续等待

好处：解决了多线程的安全问题
弊端：效率非常低，多个线程需要判断锁，比较消耗资源，抢锁的资源。

什么是线程之间同步？
同步是保证多个线程之间共享同一个全局变量数据安全问题，保证数据原子性。

多线程三大特性：
	原子性：保证线程独一无二，一致性，保证线程安全问题
	可见性：java的内存模型，当一个线程访问一个变量时，一个线程修改了这个变量的值，
		其他线程能够立即看得到修改的值
	有序性：join，wait


单例模式：
	1.饿汉模式（立即加载方式）：在类加载初始化的时候就创建好一个静态的对象供外部使用，
		除非系统重启，这个对象不会改变，所以本身就是线程安全的
	
	2.懒汉式单利（延迟加载方式）：虽然用延迟加载方式实现了单例，但在多线程环境下会产生多个实例，如果想要进一步
		改造，可以使用同步锁，这样可以解决多线程安全问题。


数据结构和算法：
	1.用类封装数组实现数据结构
        通过上面的代码，我们发现数组是能完成一个数据结构所有的功能的，而且实现起来也不难，那数据既然能完成所有的工作，我们实际应用中为啥不用它来进行所有的数据存储呢？那肯定是有原因呢。

　　  数组的局限性分析：
        ①、插入快，对于无序数组，上面我们实现的数组就是无序的，即元素没有按照从大到小或者某个特定的顺序排列，只是按照插入的顺序排列。无序数组增加一个元素很简单，只需要在数组末尾添加元素即可，
        但是有序数组却不一定了，它需要在指定的位置插入。

        ②、查找慢，当然如果根据下标来查找是很快的。但是通常我们都是根据元素值来查找，给定一个元素值，对于无序数组，我们需要从数组第一个元素开始遍历，直到找到那个元素。有序数组通过特定的算法
        查找的速度会比无需数组快，后面我们会讲各种排序算法。
        
        ③、删除慢，根据元素值删除，我们要先找到该元素所处的位置，然后将元素后面的值整体向前面移动一个位置。也需要比较多的时间。

        很显然，数组虽然插入快，但是查找和删除都比较慢，而且扩展性差，所以我们一般不会用数组来存储数据，那有没有什么数据结构插入、查找、删除都很快，而且还能动态扩展存储个数大小呢，答案是有的，
        但是这是建立在很复杂的算法基础上，后面我们也会详细讲解。
        



Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
	工作原理：包括四大核心，provider(生产者，服务提供者)，consumer（服务消费者），registry（服务注册中心）,monitor	（服务监控中心）.
	调用流程：1.服务提供者在启动时，向注册中心注册自己提供的服务。 2.服务消费者在启动时，向注册中心订阅自己所需的服		务3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。

activeMq:异步处理，应用解耦，流量肖锋
    异步处理场景说明：用户下单后，需要发送邮件和通知短信。传统做法包括：1.串行的方式；2.并行方式
        缺点：传统方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈
    引入消息队列后，发邮件和短信将不是主要业务
	
    应用解耦场景说明：分布式系统中，用户下单后，订单系统需要通知库存系统，传统的做法是调用库存接口。
        缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败
            订单系统与库存系统耦合
        解决：1.订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功，请等待物流配送
              2.库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。
              假如在下单时库存系统不能正常使用，也不影响正常下单。因为下单后，订单系统写入消息队列就不在关心其他的后续操作了
                实现了订单系统与库存系统的应用解耦
    流量肖锋应用场景： 秒杀活动一般会因为流量过大，导致流量暴增，应用容易挂掉，为解决这个问题，一般需要在应用前端加入
            消息队列 
        1.可以控制活动人数，
        2。可以缓解短时间内高流量压垮应用
      1.用户的请求，服务器接收后，首先写入消息队列，假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面
      2。秒杀业务根据消息队列中的请求消息，再做后续处理
    
上岁秋分归故里，有幸与其初相识。
问汝不知情何意？含羞却道你先语。
外文畅谈甚是欢，且因无衔以心烦。
三月电话微信通，不问对方以何容。
三观星座
犹记当时跨年夜，感恩长聊两钟头。
年年岁岁盼过年，切切急急再相见。


赠予红包表我意，仅因佩奇它不知
凤凰山上以拜佛，为其求得上上签，
重游故地以探寻，祝语悬挂树两端。
眼看手写亲笔记，无语凝噎成回忆。
无关痛痒以试探，曲意逢迎以成全。
又年十月把家还，目盯吉他泪满面。
感慨若只如初见，何时秋风悲画扇
等闲却道故人心，却道故人心易变
生平首次动情长，结局如歌撞南墙
此情可待成追忆,只是当时已惘然
// 不为此役留阴影，
    

对象的初始化顺序：

　　首先执行父类静态的内容，父类静态的内容执行完毕后，接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，再去看父类有没有构造代码块，
        如果有就执行父类的构造代码块，父类的构造代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有构造代码块，
        如果有就执行子类的构造代码块。子类的构造代码块执行完毕再去执行子类的构造方法。
    总之一句话，静态代码块内容先执行，接着执行父类构造代码块和构造方法，然后执行子类构造代码块和构造方法
	
	一世莲花一世仙，我命由我不由天。很多人喜欢认命，但如若我们没好好努力过，又怎知不能改变自己的命运呢

数据结构之链表
    链表是一种常见的基础数据结构，是一种线性变，但是并不会按线性的顺序存储数据，而是在每一个节点李
        存到下一个节点的指针，使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构
        可以充分利用计算机内存空间，实现灵活的内存动态管理，但是链表失去了数组随机读取的优点。
        同时链表由于增加了节点的指针域，空间开销比较大
    单向链表：一个单链表的节点（Node）分为两个部分，第一个部分（data）保存或者显示关于节点的信息，另一个部分存储下一个节点的地址
        最后一个节点存储地址的部分指向空值
     单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，
     对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点
     的next指向该节点的下一个节点
	今天没有什么特别的想说的，只是上了一天班有点累了。九点半到家的那一刻，真想抛开全世界的烦恼，倒头睡个三天三夜。
	想想还是算了，一个有梦之人 是没有懒惰的权利的。于是 习惯性带上耳机，听着熟悉的旋律，歌词入心，歌声入耳。有时
	 也会跟着哼上几句，渐渐的 你会发现 你会爱上一首歌，可能是因为歌手的独特音色，
	可能是因为旋律的起伏有力，也可能是听着听着发现自己已成曲中人。
	其实，音乐不止是音乐。还是一个灵魂，可以让人信仰让人找回自我的灵魂。 林夕说：“谁能改变人生的长度 谁知道永恒有多么恐怖，
	谁了解生存往往比命运还残酷 只是没有人愿意认输”
。方文山说：“在你心中我不再受宠 我的天空是雨是风还是彩虹 你在操纵”，黄家驹却说“原谅我一生不羁放纵爱自由，也会怕有一天会跌到”。
	他们在给音乐赋予力量的同时，也在传递着一种情感精神，这才是音乐的魅力。我也是一个音乐爱好者，习惯一个人听歌，唱歌。
	            
        //明知自己唱的一团糟，但是还总会与自己喜欢的人去分享。我想，
            // 这就是爱的表达吧。所想所言都放在歌里了。    
	
	
想说的话很多

nginx:反向代理是指以代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，
	并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为
	一个服务器。
     nginx支持的负载均衡调度算法方式如下：
	1.weight轮询(默认)：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器挂掉，
		nginx会自动将该服务器剔除队列，请求受理情况不会受到任何影响，这种方式下，可以给不同的后端服务器设置一个
		权重值，用于调整不同的服务器上请求的分配率，权重数据越大，被分配到请求的几率越大。
    
     	2.ip_hash:每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端		服务器，这也在一定程度上解决了集群部署环境下session共享的问题。
	没能喝上你们的喜酒。相亲相爱，白头到老。

dubbo三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现

容错：当集群中某一节点没及时返回数据时，需要有集群容错机制

7.4L~8.7L/100km 

10.6L/100公里
	
栈：

链表：一个链表的节点Node分为两个部分，第一个部分data保存或者显示关于节点的信息，另一个部分存储下一个节点的地址，最后
	一个节点存储地址的部分指向空值

平台主要为手机性能测试专项提升测试效率。因存在模块专项测试用例较多；各模块专项自动化工具繁多，工具签名及新平台适配复杂；自动化团队的工具缺乏统一的管理；没能自动收集整理测试结果以及对比测试数据，也无法形成测试效果的标准化输出等问题，所以此平台主要是实现手机性能测试实时监控的自动化平台。任务控制中心，用例管理，设备监控，消息中心，数据分析，任务监控，tt通知，邮件通知


1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。

2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。

线程池帮我们重复管理线程，避免创建大量的线程增加开销。
优点：线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。
      可以根据系统的承受压力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。
线程池的实现原理：提交一个任务到线程池中，判断线程池里的核心线程是否在执行任务，如果核心线程是空闲的或者还有核心线程没有被创建，则创建一个新的工作线程来执行任务，如果核心线程都在执行任务，则进入下个流程。
线程池判断工作队列是否已满，如工作队列没有满，则将新提交的任务存储在这个工作队列里，如果工作队列满了，则进入下个流程
判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

数据库优化：分库分表，分库分表尽量在数据库设计初期敲定方案，垂直分表：如按照日期等外部变量进行分表，水平分表是按照表中某些字段关系，使用hash映射等分表。前提条件是在查询之前，已经知道需要查询的数据可能会落在哪一个分库和哪一个分表中。
	添加缓存
	sql本身进行优化，join连接代替子查询，避免全表扫描，表的字段结构tinyint 代替状态tinyint


事物的隔离级别
	Read uncommitted

读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。
事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交

Read committed

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…

分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。

Repeatable read

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
Serializable 序列化

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。


一个属于类锁，一个属于对象锁，类锁可以对类的所有实例起作用
synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 
1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 
4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。


并发控制，实现数据库的并发访问

实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。索引可以大大提高MySQL的检索速度

虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件

FULLTEXT，HASH，BTREE，RTREE


DECLARE <游标名> CURSOR FOR select语句;
针对游标的优缺点，我总结游标的使用场景，主要用在循环处理、存储过程、函数中使用，用来查询结果集，就比如：我们需要从表中循环判断并得到想要的结果集，这时候使用游标操作很方便速度也很快

游标的设计是一种数据缓冲区的思想，用来存放SQL语句执行的结果

1.8新特性
	Lambda 表达式 ? Lambda允许把函数作为一个方法的参数
	加强对日期与时间的处理
	Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常
	添加一个非抽象的方法实现，只需要使用 default关键字即可，在接口中可以使用default和static关键字来修饰接口中定义的普通方法
	对Base64编码的支持


Java在方法调用传递参数时，因为没有指针，所以它都是进行传值调用，可以理解成传引用变量的副本值

JVM加载的是.class文件。其实，类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。


JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器

每个JVM都包含：

方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器

unicode编码占用两个字节，所以，char类型的变量也是占用两个字节

使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的

构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload

接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类中可以有静态的main方法。

内部类就是在一个类的内部定义的类，内部类中不能定义静态成员。内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中

内部类可以引用它的包含类的成员吗？有没有什么限制？
完全可以。如果不是静态内部类，那没有什么限制！

两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。

数组没有length()这个方法，有length的属性。String有有length()这个方法。
遇见你真好，但是遇见你 竟花光我所有运气。
2020年 祝好 万事胜意
主要相同点：Lock能完成synchronized所实现的所有功能

主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放

Vector默认增长为原来两倍(线程安全)，而ArrayList的增长策略在文档中没有明确规定(线程不安全)

垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况

forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。
   redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。

Scrum敏捷式开发，迭代开发的三种角色：Product Owner、Scrum Master、Team

拦截器与过滤器的区别 ：


拦截器是基于java的反射机制的，而过滤器是基于函数回调。
拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次


比如：订单系统请求库存系统，结果一个请求过去，因为各种原因，网络超时，在规定几秒内没反应，或者服务本身就挂了，这时候更多的请求来了，不断的请求库存服务，不断的创建线程，因为没有返回，也就资源没有释放

c+a+v
c+g
c+s+n find file
c+a+L format
c+s+u big small transfer

抽取成员变量快捷键 c+a+f

lambda ::作用

















