接口安全性：
	1. 签名
	2. 加密
	
操作：
1. 首先在启动类上增加 @EnableEncrypt 注解开启加解密操作。
2. 增加加密的配置：spring.encrypt.key：加密key，必须是16位
	spring.encrypt.debug：是否开启调试模式,默认为false,如果为true则不启用加解密操作
3.为了考虑通用性，不会对所有请求都执行加解密，基于注解来做控制
	响应数据需要加密的话，就在Controller的方法上加@Encrypt注解即可。

4.还有一种操作就是前段提交的数据，分为2种情况，一种是get请求，这种暂时没处理，后面再考虑。
	目前只处理的post请求，基于json格式提交的方式，也就是说后台需要用@RequestBody接收数据才行,
	需要解密的操作我们加上@Decrypt注解即可。
5. 加了@Decrypt注解后，前端提交的数据需要按照AES加密算法，进行加密，然后提交到后端，后端这边会自动解密，然后再映射到参数对象中。
	上面讲解的都是后端的代码，前端使用的话我们以js来讲解，当然你也能用别的语言来做，如果是原生的安卓app也是用java代码来处理。
前端需要做的就2件事情：
	1、统一处理数据的响应，在渲染到页面之前进行解密操作
	2、当有POST请求的数据发出时，统一加密
	我们以axios来作为请求数据的框架，用axios的拦截器来统一处理加密解密操作，首先还是要封装一个js加解密的类，
	需要注意的是加密的key需要和后台的对上，不然无法相互解密。
6. 到此为止，我们就为整个前后端交互的通信做了一个加密的操作，只要加密的key不泄露，别人得到你的数据也没用，问题是如何保证key不泄露呢
   服务端的安全性较高，可以存储在数据库中或者配置文件中，毕竟在我们自己的服务器上，最危险的其实就时前端了，app还好，可以打包，但是要防止反编译等等问题。

7.加密算法有对称加密和非对称加密，AES是对称加密，RSA是非对称加密。之所以用AES加密数据是因为效率高，RSA运行速度慢,可以用于签名操作。
	我们可以用这2种算法互补，来保证安全性，用RSA来加密传输AES的秘钥，用AES来加密数据，两者相互结合，优势互补。

	其实大家理解了HTTPS的原理的话对于下面的内容应该是一看就懂的，HTTPS比HTTP慢的原因都是因为需要让客户端与服务器端安全地协商出一个对称加密算法
	剩下的就是通信时双方使用这个对称加密算法进行加密解密。
8. 客户端启动，发送请求到服务端，服务端用RSA算法生成一对公钥和私钥，我们简称为pubkey1,prikey1，将公钥pubkey1返回给客户端。
9. 客户端拿到服务端返回的公钥pubkey1后，自己用RSA算法生成一对公钥和私钥，我们简称为pubkey2,prikey2，并将公钥pubkey2通过公钥pubkey1加密，加密之后传输给服务端
10.此时服务端收到客户端传输的密文，用私钥prikey1进行解密，因为数据是用公钥pubkey1加密的，通过解密就可以得到客户端生成的公钥pubkey2
11. 然后自己在生成对称加密，也就是我们的AES,其实也就是相对于我们配置中的那个16的长度的加密key,生成了这个key之后我们就用公钥pubkey2进行加密，返回给客户端，
    因为只有客户端有pubkey2对应的私钥prikey2，只有客户端才能解密，客户端得到数据之后，用prikey2进行解密操作，得到AES的加密key,最后就用加密key进行数据传输的加密，
	至此整个流程结束。


二.     根据用户名或者用户id，结合用户的ip或者设备号，生成一个token。在请求后台，后台获取http的head中的token，校验是否合法
		（和数据库或者redis中记录的是否一致，在登录或者初始化的时候，存入数据库/redis）
		在使用Base64方式的编码后，Token字符串还是有20多位，有的时候还是嫌它长了。由于GUID本身就有128bit，在要求有良好的可读性的前提下
		很难进一步改进了。那我们如何产生更短的字符串呢？还有一种方式就是较少Token的长度，不用GUID，而采用一定长度的随机数，例如64bit，再用Base64编码表示：



























