1. redis 穿透 雪崩 分布式锁 存储类型 
2. 线程池的创建类型 原理。
3. springboot运行机制
4. 接口安全性：
	基于网关实现黑明单与白名单拦截
	使用token+图形验证码方法实现防止模拟请求
	使用对ip访问实现接口的限流,对短时间内同一个请求(ip)一直访问接口 进行限制
	使用MD5实现对接口加签，目的是为了防止篡改数据。(SecretKey 只用作生成签名不做参数传输)
5. jvm
	类装载器ClassLoader：用来装载.class文件
	运行时数据区：方法区(类信息，常量池，静态变量)、堆(new 出来的对象和数组)、Java栈(基本数据类型和对象的引用)、程序计数器、本地方法栈
	1、加载.class文件

	2、管理并分配内存

	3、执行垃圾收集
6. 分布式事物
	1. MQ实现消息的一致性(RocketMQ )
	2. 两阶段提交协议
		1、应用程序连接两个数据源。
		2、应用程序通过事务协调器向两个库发起prepare，两个数据库收到消息分别执行本地事务（记录日志），但不提交，如果执行成功则回复yes，否则回复no。
		3、事务协调器收到回复，只要有一方回复no则分别向参与者发起回滚事务，参与者开始回滚事务。
		4、事务协调器收到回复，全部回复yes，此时向参与者发起提交事务。如果参与者有一方提交事务失败则由事务协调器发起回滚事务。
		缺点：整个事务的执行需要由协调者在多个节点之间去协调，增加了事务的执行时间，性能低下
	事物的传播行为：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播 例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行
		支持当前事物的情况：
		PROPAGATION_REQUIRED: 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。
		PROPAGATION_SUPPORTS: 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。
		PROPAGATION_MANDATORY: 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(mandatory:强制性)
	事物隔离级别:
	
	
7. mysql读写分离
	保证主从数据库数据的一致性：
		MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，
		它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，
		并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，
		然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。

8. 分布式锁
	可重入锁：同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁	
	1. 执行lua脚本，设置 hset myLock，生成hash数据结构 执行 pexpire myLock 30000 
	2. 先判断key是否存在 再判断hash结构中是否包含客户端id，然后会获取锁的生存时间，此时客户端2进入循环 不通尝试加锁
9. kafka场景
	1. 日志收集 2. 用户活动跟踪 3.消息处理
10. 索引类型的分类
		1. 普通索引 2.主键索引 (主键唯一性， 不能为空) 3.联合索引(多列组成的索引，需要加索引的字段，要在where条件中,最左原则) 4.全文索引(主要针对文本的内容进行分词)
	索引结构分类
		1.B-tree索引（默认引擎是innodb。索引的数据结构是B+树）
			B-tree 索引普遍存在于存储引擎中，他使用B-tree数据结构来存储数据，如果对树形数据结构比较了解的话，就知道B-tree索引所带来的好处了，
			他的每个叶子节点都会包含下一个节点的指针，非常方便查询数据
		2.哈希索引
			哈希索引基于哈希表实现，对于每一行数据，存储引擎会对所有的索引列计算一个哈希码，然后存储引擎会基于这个哈希码来查找数据，小编感觉有点像HashMap 中槽的查询过程
		3.全文索引
			全文索引在几种索引结构类型中比较特殊，他查找的是文本中关键词
	建议不要使用索引的几种情况：
		2. 频繁更新的字段 4. 不在where列中出现的索引 1. 区分度不是很大的字段
	索引失效的几种情况：
		 1. 查询列中有函数计算 2. 查询列中有模糊查询 5. is null 或者 is not null
	5. explain 分析查询sql
11. INNODB存储引擎 聚簇索引(B+tree实现，按照B+树的检索算法即可查找到对应的叶节点)

	MyISAM存储引擎
	
12. 数组与链表（数据域和指针域）
		链表：头指针指向链表的第一个节点，然后第一个节点中的指针指向下一个节点，然后依次指到最后一个节点，最后一个节点指向NUL，增加和删除快，只需要修改元素中的指针就可以
			查询速度慢，查询效率低，对链表进行遍历
	链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储，增删慢，因为要移动元素，查询效率高：ArrayLIst是连续存放元素的，找到第一个元素的首地址，再加上每个元素的占据的字节大小就能定位到对应的元素
	
	
13. //springboot 自动装配，首先会通过配置文件，自动装配所属的依赖类，再用动态代理的方式注入到spring容器里面

14. redis存储类型
	1.list类型 适用于列表试存储且顺序比较固定 如 省份 城市等
	2.set类型 当需要存储一个列表数据,又不希望出现重复数据
	3.sortedset类型 你需要一个有序的并且不重复的集合列表,那么可以选择zset数据结构 根据时间排序的新闻列表
	4.hash类型 类似于表记录的存储
	5.hash类型 对数据的一条数据或者是一个对象转换成hashmap进行存储
15. nginx 
		1. 默认轮询 按时间分配
		2.权重 按比例分配
		3.iphash 按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器
	nginx技术, 用于配置正向代理和反向代理 . 正向代理,代理在客户端,服务端不知道实际发起请求的客户端 反向代理,代理在服务端, 
	客户端不知道实际提供服务的服务端. 反向代理常用于分摊服务器的压力, 即实现服务器的负载均衡. 通过配置虚拟主机 .
	,实现一台主机对外提供多个web服务 ,且他们之间互不影响.虚拟主机的配置分为基于ip ,基于端口 ,基于域名的配置.
	
16. kafka
		Kafka 为每个主题维护了分布式的分区(Partition)日志文件，每个 Partition 在 Kafka 存储层面是 Append Log。
		任何发布到此 Partition 的消息都会被追加到 Log 文件的尾部，在分区中的每条消息都会按照时间顺序分配到一个单调递增的顺序编号，也就是我们的 Offset
		通过这个 Offset 可以确定一条在该 Partition 下的唯一消息
	kafa生产者数据不丢失： 在kafka发送数据的时候，每次发送消息都会有一个确认反馈机制，确保消息正常的能够被收到 可以通过配置保证消息的不丢失
	消费者数据的不丢失：kafka自己记录了每次消费的offset数值，下次继续消费的时候，接着上次的offset进行消费即可。
	
	kafka 重复消费的原因：
		底层根本原因：已经消费了数据，但是offset没提交。
		原因1：强行kill线程，导致消费后的数据，offset没有提交。
		原因2：消费后的数据，当offset还没有提交时，partition就断开连接
	解决方案：维护offset 。记录offset和恢复offset的方案
		每次消费时更新每个topic+partition位置的offset在内存中，  Map<key, value>，key=topic+'-'+partition，value=offset
	
	
17. 集群环境定时任务重复执行
	解决方案：
	1. 分布式锁是最常用的一种方式，需要对定时逻辑加上一些判断，防止在同一时间重复执行
	2.定时任务单节点执行 把定时任务逻辑都单独拎出来作为一个单独的微服务来执行 优点：简单 缺点： 单节点故障
	3。Quartz集群 如果是使用的quartz框架的话，也可以考虑quartz本身提供的集群功能，搭建集群环境下的定时任务 11张表
	
18. restful :为了方便不同设备前后端交互通信，就需要有一种统一的机制，即RESTful，通过统一的接口为不同设备提供服务;
		对于该URL标识的资源做何种操作是由Http的动词决定的。 rest请求方法有4种，包括get,post,put,delete.分别对应获取资源，
		添加资源，更新资源及删除资源.
		
19.如何处理并发？
	a. 添加负载均衡层，将请求均匀打到系统层。
	b. 系统层采用集群化部署多台机器，抗住初步的并发压力。
	c. 数据库分库分表 + 读写分离
	d. 可以根据系统的业务特性，对那种写少读多的请求，引入缓存集群。
	e. 比如说消息中间件技术，也就是MQ集群，是非常好的做写请求异步化处理，实现削峰填谷的效果。
20.aop： aop 面向切面编程，底层的实现主要是动态代理，而我们在项目中应用比如包括日志记录，事物处理等（前置通知，后置通知，环绕通知，异常通知，返回通知等）
ioc： 如果A类调用B，传统的方法是在A里new 一个B的实例，那么这样的话两者之间就会产生依赖，而引入ioc就是要实例注入到spring容器，并交给spring去管理，降低耦合度

21.docker 部署springcloud
	1. 打包eureka.jar 打包 打包服务task.jar 打包zuul.jar将三个微服务打成jar包，并上传到服务器
	2. 编写各自的Dockerfile
	3. 分别将三个jar打成镜像
	4. 接着运行三个镜像并且映射了端口号
	5. 修改三个微服务项目的application.yml配置文件，追加 eureka.instance.prefer-ip-address: true（表示微服务显示IP）
	6. 容器会像虚拟机一样自动被分配了一个虚拟ID，并映射了主机的端口号，这样便可以从外部访问到容器并且能够实现容器间的通讯了

	1、FROM

		指令必须指定且需要在Dockerfile其他指令的前面，指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。后续的指令都依赖于该指令指定的image。当在同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令。
	2、ADD

		从src目录复制文件到容器的dest，可以是一个URL，还可以是一个jar包
	
	3、EXPOSE

		为Docker容器设置对外的端口号。在启动时，可以使用-p选项或者-P选项。
	4、ENTRYPOINT

		该命令制定Docker容器启动时执行的命令，可多次设置，但只有最后一条会生效ss。
		111111